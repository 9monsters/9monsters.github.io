---
title: Spring的事务管理
date: 2016-07-25 15:50:23
updated: 2016-12-15 22:10:21
categories:
    - Spring
tags:
    - Spring
    - 事务管理
keywords: spring 事务管理
description:
    事务及Spring 事务管理
---
`Spring`的事务管理分为 `编程式` 与`声明式`两种；
本文主要介绍 `Spring` 的 `声明式事务管理`

## 什么是声明式事务
`声明式事务`就是使用注解来选择需要使用事务的方法， 使用`@Transactional `注解在方法上， 表明该方法需要事务支持。
这个是典型的 `AOP` 的实现， 当被注解的方法被调用的时候， `Spring`会开启一个新的事务， 
当该方法无异常完成后， `Spring` 会提交这个事务。

```java
@Transactional
public void save(){

}

```

## 如何开启事务管理

`Spring` 提供了`@EnableTransactionManagement` 注解在配置类上 _（基于 `JAVA config`）_ 用以开启`声明式事务`。
使用`@EnableTransactionManagement` 后 ， `Spring `会自动扫描注解`@Transactional`的方法和类。

```java
@Configuration
@EnableTransactionManagement
public class AppConfig{

}

```

## 注解事务行为

### Spring中事务属性

`Spring`使用`AOP`来完成声明式的事务管理，因而声明式事务是以`方法`为单位，`Spring`的事务属性自然就在于描述事务应用至方法上的策略

在Spring中事务属性有以下参数：

|属性|	类型|	描述|
|--|:--:|:--:|
|propagation|	枚举型：Propagation	可选的传播性设置|
|isolation|	枚举型：Isolation	可选的隔离性级别（默认值：ISOLATION_DEFAULT）|
|readOnly|	布尔型	读写型事务 vs. 只读型事务|
|timeout|	int型（以秒为单位）	事务超时|
|rollbackFor|	一组Class类的实例，必须是Throwable的子类	一组异常类，遇到时 必须 进行回滚。默认情况下checked exceptions不进行回滚，仅unchecked exceptions（即RuntimeException的子类）才进行事务回滚。|
|rollbackForClassname|	一组Class类的名字，必须是Throwable的子类	一组异常类名，遇到时 必须 进行回滚|
|noRollbackFor|	一组Class类的实例，必须是Throwable的子类	一组异常类，遇到时 必须不 回滚。|
|noRollbackForClassname|	一组Class类的名字，必须是Throwable的子类	一组异常类，遇到时 必须不 回滚|

### Spring传播行为

|属性|	描述|
|--|:--:|
|REQUIRED|	业务方法需要在一个事务中运行,如果方法运行时,已处在一个事务中,那么就加入该事务,否则自己创建一个新的事务.这是spring默认的传播行为.|
|SUPPORTS|	如果业务方法在某个事务范围内被调用,则方法成为该事务的一部分,如果业务方法在事务范围外被调用,则方法在没有事务的环境下执行.|
|MANDATORY|	只能在一个已存在事务中执行,业务方法不能发起自己的事务,如果业务方法在没有事务的环境下调用,就抛异常|
|REQUIRES_NEW|	业务方法总是会为自己发起一个新的事务,如果方法已运行在一个事务中,则原有事务被挂起,新的事务被创建,直到方法结束,新事务才结束,原先的事务才会恢复执行.|
|NOT_SUPPORTED|	声明方法需要事务,如果方法没有关联到一个事务,容器不会为它开启事务.如果方法在一个事务中被调用,该事务会被挂起,在方法调用结束后,原先的事务便会恢复执行.|
|NEVER|	声明方法绝对不能在事务范围内执行,如果方法在某个事务范围内执行,容器就抛异常.只有没关联到事务,才正常执行.|
|NESTED|	如果一个活动的事务存在,则运行在一个嵌套的事务中.如果没有活动的事务,则按REQUIRED属性执行.它使用了一个单独的事务, 这个事务拥有多个可以回滚的保证点.内部事务回滚不会对外部事务造成影响, 它只对DataSourceTransactionManager 事务管理器起效.|

详细解释如下：

- __Required__
    默认的事务传播行为，表示必须有逻辑事务，否则新建一个事务，使用`PROPAGATION_REQUIRED`指定，表示如果当前存在一个逻辑事务，则加入该逻辑事务，否则将新建一个逻辑事务：
    
- __RequiresNew__
    创建新的逻辑事务，使用`PROPAGATION_REQUIRES_NEW`指定，表示每次都创建新的逻辑事务（物理事务也是不同的）因此外部事务可以不受内部事务回滚状态的影响独立提交或者回滚。

- __Supports__
    支持当前事务，使用`PROPAGATION_SUPPORTS`指定，指如果当前存在逻辑事务，就加入到该逻辑事务，如果当前没有逻辑事务，就以非事务方式执行。

- __NotSupported__
    不支持事务，如果当前存在事务则暂停该事务，使用`PROPAGATION_NOT_SUPPORTED`指定，即以非事务方式执行，如果当前存在逻辑事务，就把当前事务暂停，以非事务方式执行。

- __Mandatory__
    使用`PROPAGATION_MANDATORY`指定，如果当前有事务，使用当前事务执行，如果当前没有事务，则抛出异常 _（IllegalTransactionStateException）_。

- __Never__
    不支持事务，如果当前存在是事务则抛出`IllegalTransactionStateException`异常，使用`PROPAGATION_NEVER`指定。

- __Nested__
    嵌套事务支持，使用`PROPAGATION_NESTED`指定，如果当前存在事务，则在嵌套事务内执行，如果当前不存在事务，则创建一个新的事务，嵌套事务使用数据库中的保存点来实现，即嵌套事务回滚不影响外部事务，但外部事务回滚将导致嵌套事务回滚。

### Nested和RequiresNew的区别

`RequiresNew`每次都创建新的独立的物理事务，而`Nested`只有一个物理事务；
`Nested`嵌套事务回滚或提交不会导致外部事务回滚或提交，但外部事务回滚将导致嵌套事务回滚，而 `RequiresNew`由于都是全新的事务，所以之间是无关联的；
`Nested`使用`JDBC`的保存点实现，即如果使用低版本驱动将导致不支持嵌套事务。
实际应用中一般使用默认的事务传播行为，偶尔会用到`RequiresNew和Nested`方式。


## Spring的隔离级别

声明式事务的第二个方面是隔离级别。
隔离级别定义一个事务可能受其他并发事务活动活动影响的程度。
另一种考虑一个事务的隔离级别的方式，是把它想象为那个事务对于事物处理数据的自私程度。

在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。
并发虽然是必需的，但是会导致以下> > 下问题：

### 丢失更新
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。 　　

例:
> 事务A和事务B同时修改某行的值，
> 1. 事务A将数值改为1并提交
> 2. 事务B将数值改为2并提交。
> 这时数据的值为2，事务A所做的更新将会丢失。 
> 解决办法：对行加锁，只允许并发一个更新事务。


### 脏读

一个事务读到另一个事务未提交的更新数据

例:

> 1. Mry的原工资为1000, 财务人员将Mary的工资改为了8000(但未提交事务)         
> 2. Mary读取自己的工资 ,发现自己的工资变为了8000，欢天喜地！
> 3. 而财务发现操作有误，回滚了事务,Mary的工资又变为了1000, 像这样,Mary记取的工资数8000是一个脏数据。

### 不可重复读

在同一个事务中,多次读取同一数据,返回的结果有所不同. 换句话说就是,后续读取可以读到另一个事务已提交的更新数据. 相反"可重复读"在同一事务多次读取数据时,能够保证所读数据一样,也就是后续读取不能读到另一事务已提交的更新数据.

例:

> 1. 在事务1中，Mary 读取了自己的工资为1000,操作并没有完成
> 2. 在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.
> 3. 在事务1中，Mary 再次读取自己的工资时，工资变为了2000
> 解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。> 

### 幻读

一个事务读取到另一个事务已提交的insert数据.

例:

> 第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时 (此时第一事务还未提交) ，第二个事务向表中插入一行新数据。这时第一个事务再去读取表时,发现表中还有没有修改的数据行，就好象发生了幻觉一样。
> 
> 在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常牵扯到锁定在数据库中的记录（而且有时是锁定完整的数据表）。侵占性的锁定会阻碍并发，要求事务相互等待来完成工作。
> 
> 考虑到完全隔离会影响性能，而且并不是所有应用程序都要求完全隔离，所以有时可以在事务隔离方面灵活处理。因此，就会有好几个隔离级别。



### 隔离级别

含义

#### ISOLATION_DEFAULT

使用后端数据库默认的隔离级别。

#### ISOLATION_READ_UNCOMMITTED

允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。

#### ISOLATION_READ_COMMITTED

允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。

#### ISOLATION_REPEATABLE_READ

对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。

#### ISOLATION_SERIALIZABLE

完全服从`ACID`> 的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。

详细解释如下：

 > 1. ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
 >     另外四个与JDBC的隔离级别相对应
 > 2. ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。
 >     这种隔离级别会产生脏读，不可重复读和幻像读。
 > 3. ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据
 > 4. ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。
 >     它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。
 > 5. ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。
      除了防止脏读，不可重复读外，还避免了幻像读。
